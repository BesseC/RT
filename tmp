float	ft_fresnel(t_ray *ray, t_record *r)
{
	float cosi;
	float etat = IOR;
	float etai = 1;
	float sint;
	float cost;
	float rs;
	float rp;

	cosi = v_dot(ray->dir, r[0].normal);
	if (cosi > 0)
	{
		etai = 1;
		etai = IOR;
	}
	sint = etai / etat * sqrtf(1 - cosi * cosi);
	if(sint >= 1)
		return(1);
	else
	{
		cost = sqrtf(1 - sint * sint);
		cosi = fabsf(cosi);
		rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));
		rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));
		return((rs * rs + rp * rp) / 2);
	}

	/*
  --  float cosi = clamp(-1, 1, dotProduct(I, N));
	--  float etai = 1, etat = ior;
  --  if (cosi > 0) { std::swap(etai, etat); }
  --  // Compute sini using Snell's law
  --  float sint = etai / etat * sqrtf(std::max(0.f, 1 - cosi * cosi));
  --  // Total internal reflection
  --  if (sint >= 1) {
  --      kr = 1;
  --  }
  --  else {
  --      float cost = sqrtf(std::max(0.f, 1 - sint * sint));
  --      cosi = fabsf(cosi);
        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));
        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));
        kr = (Rs * Rs + Rp * Rp) / 2;
    } */
}
vr = c_shadow(scene.light, &r[0], vr, i);
v_mult(vr, 1 - r[1].kt);


vr.x = vr.x + r[1].kt;
vr.y = vr.y + r[1].kt;
vr.z = vr.z + r[1].kt;


v_norm(v_less(scene.light[i], r[0].p))


p = v_add(ray->ori, v_mult(ray->dir, t));
oc = v_less(p, fcone->apex);
if (v_dot(v_normalize(fcone->dir), v_normalize(oc)) > 0)
	temp = v_set(fcone->dir.x, fcone->dir.y, fcone->dir.z);
else
	temp = v_set(-fcone->dir.x, -fcone->dir.y, -fcone->dir.z);
uv = v_norm(oc) / cos(fcone->angle / 2);
temp = v_normalize(v_less(oc, v_mult(temp, uv)));
uv = sin(M_PI/2 - fcone->angle) * (v_norm(oc) / cos(fcone->angle));
temp = v_set(-temp.x, -temp.y, -temp.z);
pv = v_add(p, v_mult(temp, uv));
ok = v_norm(v_less(p, fcone->apex));
printf("%f\n", ok);
